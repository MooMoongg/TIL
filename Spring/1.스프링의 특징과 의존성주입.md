# Chapter02. 스프링의 특징과 의존성 주입

## 학습목표

1. Java 관련 프레임워크들이 추구했던 목표
2. 스프링 프레임워크가 살아남은 이유
3. 의존성 주입

---

## 용어 정리

### POJO (Plain Old Java Object)

특별한 기술 없이도 평범하게 동작하는 Java 객체

### Cross-concern (횡단 관심사)

시스템이 공통으로 가지고 있는 보안, 로그, 트랜잭션과 같이  
비즈니스 로직은 아니지만, 반드시 처리가 필요한 부분을  
스프링에서는 **Cross-concern**이라고 한다.

---

## 키워드

### ApplicationContext

스프링에서는 `ApplicationContext`라는 존재가 **필요한 객체들을 생성하고, 필요한 객체들을 주입하는 역할**을 해 주는 구조

스프링에서는 `ApplicationContext`가 관리하는 객체들을 **Bean**이라고 부르고,  
Bean과 Bean 사이의 의존 관계를 처리하는 방식으로 다음 세 가지 방식을 제공한다.

1. XML 설정
2. 어노테이션 설정
3. Java 설정 방식

---

## 2.1 스프링 프레임워크의 간략한 역사

### 프레임워크란?

**뼈대나 근간을 이루는 코드들의 묶음**

### 경량 프레임워크 (light-weight Framework)

특정 기능을 위주로 **간단한 JAR 파일 등을 이용해서 모든 개발이 가능하도록** 구성된 프레임워크

---

## 2.1.1 스프링의 주요 특징

### 1. POJO (Plain Old Java Object) 기반의 구성

일반적인 **Java 코드만을 이용해서 객체를 구성하는 방식**을 스프링에서 사용 가능

### 2. 의존성 주입 (DI, Dependency Injection)

#### ✅ 의존성 (Dependency)

- 하나의 객체가 **다른 객체 없이는 제대로 된 역할을 할 수 없는 상태**
- 예시: 음식점의 주방장 (`Restaurant` → `Chef`에 의존)

#### ✅ 주입 (Injection)

- **어떤 객체가 필요한 객체를 외부에서 밀어 넣는 것**
- 예시: 음식점의 식재료 공급 (`Restaurant` → `Ingredient` 주입)

### 3. AOP (Aspect-Oriented Programming) 지원

- **Cross-concern을 분리해서 제작**하여 비즈니스 로직에만 집중할 수 있도록 함

### 4. 편리한 MVC 구조

스프링에서는 강력한 **MVC (Model-View-Controller) 구조를 지원**하여 개발을 쉽게 함

### 5. WAS에 종속적이지 않은 개발 환경

스프링을 사용하면 **웹 애플리케이션 서버(WAS)에 종속되지 않고도 개발할 수 있는 환경을 제공**

---

## 2.2 의존성 주입 테스트

스프링에서는 **두 가지 방식**으로 의존성 주입을 구현한다.

1. **생성자를 이용한 주입**
2. **Setter 메서드를 이용한 주입**

---

## 2.2.1 예제 클래스 생성

### `@Component`

- 스프링에게 **해당 클래스가 스프링에서 관리해야 하는 대상**임을 표시하는 어노테이션

### `@Setter`

- **자동으로 `setChef()`를 컴파일 시 생성**하는 Lombok 어노테이션

---

## 2.3 스프링이 동작하면서 생기는 일

1. **스프링 프레임워크 시작**

   - 가장 먼저 **스프링이 사용하는 메모리 영역을 생성**, 이를 **Context**라고 한다.
   - 스프링에서는 `ApplicationContext`라는 객체가 만들어짐.

2. **root-context.xml 역할**
   - **스프링 프레임워크에서 관리해야 하는 객체(Bean)를 설정하는 설정 파일**
   - `<context:component-scan base-package="패키지명">`
     - 패키지를 **스캔(scan)**하여, 해당 패키지 내에서  
       `@Component` 어노테이션이 존재하는 클래스의 인스턴스를 생성
   - `@Autowired`
     - `Chef` 객체의 레퍼런스를 `Restaurant` 객체에 주입

---

## 2.3.1 테스트 코드를 통한 확인

### `@RunWith(SpringJUnit4ClassRunner.class)`

- 현재 테스트 코드가 **스프링을 실행하는 역할**을 하도록 지정
- **테스트 코드에서 스프링 컨테이너를 실행**하고, **의존성을 주입**할 수 있도록 함

### `@ContextConfiguration`

- 지정된 **클래스나 설정 파일을 이용하여 필요한 객체들을 스프링 내에 등록**
- `classpath`, `file` 등의 문자열을 이용해서 어떤 설정 정보를 읽어야 하는지 지정 가능

### `@Log4j`

- **로그를 기록하는 Logger를 생성**

### `@Test`

- **JUnit에서 해당 메서드가 테스트 대상임을 표시**

---

## 📌 중요한 개념 정리

- `new Restaurant()` 와 같이 `Restaurant` 클래스를 직접 생성하지 않았음에도 **스프링이 자동으로 객체를 생성**
- 즉, **스프링은 관리가 필요한 객체(Bean)를 어노테이션 등을 이용해서 객체를 생성하고 관리하는 컨테이너 역할을 수행**
- 이는 스프링이 단순한 프레임워크가 아니라, **객체를 생성하고 관리하는 일종의 '팩토리' 기능을 가지고 있기 때문**
- 1)테스트 코드가 실행되기 위해서 스프링 프레임워크가 동작했고
- 2)동작하는 과정에서 필요한 객체들이 스프링에 등록되었고,
- 3)의존성 주입이 필요한 객체는 자동으로 주입이 이루어짐

## 2.3.2 코드에 사용된 어노테이션
1. **Lombok관련 어노테이션**

   - @Setter : setter 메서드 생성
   - @Data : @ToString, @EquealsAndHashCode, @Getter/Setter, @RequriedArgsConstructor를 모두 결합
   - @Log4J : Log 객체 생성

2. **Spring 관련 어노테이션**

   - @Autowired : 스프링 내부에서 자신이 특정한 객체에 의존적이무로 자신에게 해당 타입의 빈을 주입해주라는표시
   - @Comoponent : 해당 클래스가 스프링에서 객체로 만들어서 관리하는 대상임을 명시하는 어노테이션

3. **테스트관련 어노테이션**

   - @RunWith : 테스트 시 필요한 클래스 지정
   - @ContextConfiguration: 스프링이 실행되면서 어떤 설정 정보를 읽어 들여야 하는지를 명시한다.
   - @Test : 단위 테스트 대상

4. etc

    - onMethod : setter 메서드의 생성시 메서드에 추가할 어노테이션 지정, '_' 표기 : JDK버전에 따라 차이가 있다.